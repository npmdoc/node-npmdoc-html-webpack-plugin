<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/ampedandwired/html-webpack-plugin">html-webpack-plugin (v2.28.0)</a>
</h1>
<h4>Simplifies creation of HTML files to serve your webpack bundles</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.html-webpack-plugin">module html-webpack-plugin</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">html-webpack-plugin.</span>chunksorter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">html-webpack-plugin.</span>compiler</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.html-webpack-plugin.chunksorter">module html-webpack-plugin.chunksorter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.html-webpack-plugin.chunksorter.auto">
            function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>auto
            <span class="apidocSignatureSpan">(chunks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.html-webpack-plugin.chunksorter.dependency">
            function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>dependency
            <span class="apidocSignatureSpan">(chunks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.html-webpack-plugin.chunksorter.id">
            function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>id
            <span class="apidocSignatureSpan">(chunks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.html-webpack-plugin.chunksorter.none">
            function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>none
            <span class="apidocSignatureSpan">(chunks)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.html-webpack-plugin.compiler">module html-webpack-plugin.compiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.html-webpack-plugin.compiler.compileTemplate">
            function <span class="apidocSignatureSpan">html-webpack-plugin.compiler.</span>compileTemplate
            <span class="apidocSignatureSpan">(template, context, outputFilename, compilation)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.html-webpack-plugin" id="apidoc.module.html-webpack-plugin">module html-webpack-plugin</a></h1>





</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.html-webpack-plugin.chunksorter" id="apidoc.module.html-webpack-plugin.chunksorter">module html-webpack-plugin.chunksorter</a></h1>


    <h2>
        <a href="#apidoc.element.html-webpack-plugin.chunksorter.auto" id="apidoc.element.html-webpack-plugin.chunksorter.auto">
        function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>auto
        <span class="apidocSignatureSpan">(chunks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (chunks) {
  if (!chunks) {
    return chunks;
  }

  // We build a map (chunk-id -&gt; chunk) for faster access during graph building.
  var nodeMap = {};

  chunks.forEach(function (chunk) {
    nodeMap[chunk.id] = chunk;
  });

  // Next, we add an edge for each parent relationship into the graph
  var edges = [];

  chunks.forEach(function (chunk) {
    if (chunk.parents) {
      // Add an edge for each parent (parent -&gt; child)
      chunk.parents.forEach(function (parentId) {
        // webpack2 chunk.parents are chunks instead of string id(s)
        var parentChunk = _.isObject(parentId) ? parentId : nodeMap[parentId];
        // If the parent chunk does not exist (e.g. because of an excluded chunk)
        // we ignore that parent
        if (parentChunk) {
          edges.push([parentChunk, chunk]);
        }
      });
    }
  });
  // We now perform a topological sorting on the input chunks and built edges
  return toposort.array(chunks, edges);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.html-webpack-plugin.chunksorter.dependency" id="apidoc.element.html-webpack-plugin.chunksorter.dependency">
        function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>dependency
        <span class="apidocSignatureSpan">(chunks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dependency = function (chunks) {
  if (!chunks) {
    return chunks;
  }

  // We build a map (chunk-id -&gt; chunk) for faster access during graph building.
  var nodeMap = {};

  chunks.forEach(function (chunk) {
    nodeMap[chunk.id] = chunk;
  });

  // Next, we add an edge for each parent relationship into the graph
  var edges = [];

  chunks.forEach(function (chunk) {
    if (chunk.parents) {
      // Add an edge for each parent (parent -&gt; child)
      chunk.parents.forEach(function (parentId) {
        // webpack2 chunk.parents are chunks instead of string id(s)
        var parentChunk = _.isObject(parentId) ? parentId : nodeMap[parentId];
        // If the parent chunk does not exist (e.g. because of an excluded chunk)
        // we ignore that parent
        if (parentChunk) {
          edges.push([parentChunk, chunk]);
        }
      });
    }
  });
  // We now perform a topological sorting on the input chunks and built edges
  return toposort.array(chunks, edges);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.html-webpack-plugin.chunksorter.id" id="apidoc.element.html-webpack-plugin.chunksorter.id">
        function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>id
        <span class="apidocSignatureSpan">(chunks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id = function (chunks) {
  return chunks.sort(function orderEntryLast (a, b) {
    if (a.entry !== b.entry) {
      return b.entry ? 1 : -1;
    } else {
      return b.id - a.id;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.html-webpack-plugin.chunksorter.none" id="apidoc.element.html-webpack-plugin.chunksorter.none">
        function <span class="apidocSignatureSpan">html-webpack-plugin.chunksorter.</span>none
        <span class="apidocSignatureSpan">(chunks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">none = function (chunks) {
  return chunks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  // Custom function
  if (typeof sortMode === 'function') {
    return chunks.sort(sortMode);
  }
  // Disabled sorting:
  if (sortMode === 'none') {
    return chunkSorter.<span class="apidocCodeKeywordSpan">none</span>(chunks);
  }
  // Check if the given sort mode is a valid chunkSorter sort mode
  if (typeof chunkSorter[sortMode] !== 'undefined') {
    return chunkSorter[sortMode](chunks);
  }
  throw new Error('"' + sortMode + '" is not a valid chunk sort mode');
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.html-webpack-plugin.compiler" id="apidoc.module.html-webpack-plugin.compiler">module html-webpack-plugin.compiler</a></h1>


    <h2>
        <a href="#apidoc.element.html-webpack-plugin.compiler.compileTemplate" id="apidoc.element.html-webpack-plugin.compiler.compileTemplate">
        function <span class="apidocSignatureSpan">html-webpack-plugin.compiler.</span>compileTemplate
        <span class="apidocSignatureSpan">(template, context, outputFilename, compilation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compileTemplate(template, context, outputFilename, compilation) {
  // The entry file is just an empty helper as the dynamic template
  // require is added in "loader.js"
  var outputOptions = {
    filename: outputFilename,
    publicPath: compilation.outputOptions.publicPath
  };
  // Store the result of the parent compilation before we start the child compilation
  var assetsBeforeCompilation = _.assign({}, compilation.assets[outputOptions.filename]);
  // Create an additional child compiler which takes the template
  // and turns it into an Node.JS html factory.
  // This allows us to use loaders during the compilation
  var compilerName = getCompilerName(context, outputFilename);
  var childCompiler = compilation.createChildCompiler(compilerName, outputOptions);
  childCompiler.context = context;
  childCompiler.apply(
    new NodeTemplatePlugin(outputOptions),
    new NodeTargetPlugin(),
    new LibraryTemplatePlugin('HTML_WEBPACK_PLUGIN_RESULT', 'var'),
    new SingleEntryPlugin(this.context, template),
    new LoaderTargetPlugin('node')
  );

  // Fix for "Uncaught TypeError: __webpack_require__(...) is not a function"
  // Hot module replacement requires that every child compiler has its own
  // cache. @see https://github.com/ampedandwired/html-webpack-plugin/pull/179
  childCompiler.plugin('compilation', function (compilation) {
    if (compilation.cache) {
      if (!compilation.cache[compilerName]) {
        compilation.cache[compilerName] = {};
      }
      compilation.cache = compilation.cache[compilerName];
    }
  });

  // Compile and return a promise
  return new Promise(function (resolve, reject) {
    childCompiler.runAsChild(function (err, entries, childCompilation) {
      // Resolve / reject the promise
      if (childCompilation &amp;&amp; childCompilation.errors &amp;&amp; childCompilation.errors.length) {
        var errorDetails = childCompilation.errors.map(function (error) {
          return error.message + (error.error ? ':\n' + error.error : '');
        }).join('\n');
        reject(new Error('Child compilation failed:\n' + errorDetails));
      } else if (err) {
        reject(err);
      } else {
        // Replace [hash] placeholders in filename
        var outputName = compilation.mainTemplate.applyPluginsWaterfall('asset-path', outputOptions.filename, {
          hash: childCompilation.hash,
          chunk: entries[0]
        });
        // Restore the parent compilation to the state like it
        // was before the child compilation
        compilation.assets[outputName] = assetsBeforeCompilation[outputName];
        if (assetsBeforeCompilation[outputName] === undefined) {
          // If it wasn't there - delete it
          delete compilation.assets[outputName];
        }
        resolve({
          // Hash of the template entry point
          hash: entries[0].hash,
          // Output name
          outputName: outputName,
          // Compiled code
          content: childCompilation.assets[outputName].source()
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var filename = this.options.filename;
if (path.resolve(filename) === path.normalize(filename)) {
  this.options.filename = path.relative(compiler.options.output.path, filename);
}

compiler.plugin('make', function (compilation, callback) {
  // Compile the template (queued)
  compilationPromise = childCompiler.<span class="apidocCodeKeywordSpan">compileTemplate</span>(self.options.template, compiler.
context, self.options.filename, compilation)
    .catch(function (err) {
      compilation.errors.push(prettyError(err, compiler.context).toString());
      return {
        content: self.options.showErrors ? prettyError(err, compiler.context).toJsonHtml() : 'ERROR',
        outputName: self.options.filename
      };
    })
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>